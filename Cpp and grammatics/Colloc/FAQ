explicit A(int x) - нельзя преобразовывать
int a() const { - не меняем класс

A (A&y);
a5 = A(7) // конструктор копирования должен быть определен от константных обьектов

не закончили конструктор - деструктор не вызывается

у throw есть област ьпамяти где тоже вызываеся конструктор, причем если обьект отнаследованный то, вызывается конструктор по умолчанию базовоо класс а потом копирования исходного

постфиксный++ x.operator ++ (int a);
префиксный++ x.operator ++ ();
перегрузка -> должна в итоге давать указатель на класс

порядок в cout с конца (может меняться)

перегрузка: отождствление, расширение, сьандартные преобр пользовательские преобр, по ...
0 - преобразовывается во все что угодно на шаге 3. 

При наследовании для перекрытия, нужно чтобы только ИМЯ функции совпадало. Даже если 2 наследника с функциями с только одинаковым именем	

следить за operator= и прочее

шаблонную функцию перевешивает только отождествление
 
B: A, C: А.у В есть явно описанный конструктор копирования, у С нет.
B b1; // A (), B ()
B b2 = b1; // A (), B (const B &)
C c1; // A (), C ()
C c2 = c1; // A (const A &), C (const C &)


Виртуальность начинает работать когда появляется производный класс с функцией с таим же прототипом как и исходная

Виртуальные функции выбираются по типу обьекта на который ссылается указатель(ссылка)

Если виртуальные функции отличаются результатом - это ошибка

Делать деструкторы виртуальными

прототип функции - без возвращаемого значения

virtual void print () = 0; - чистая виртальная функция

функция вызываемая внутри виртуальной функции стовится виртуальной и виртуальность наследуется

Виртуальность: если в базовых функциях есть значения по умолчанию, они перекидваются в наследуемые (ГОЛОВА ОТ БАЗОВОГО, ТЕЛО ОТ НАСЛЕДУЕМОГО)

A : public X, Y == A : public X, private Y (X,Y == class)

throw вызывает конструктор копирования

L <-- A <-- C --> B --> L не понятно чей элемент класс L т к они все 2жды

pl = (L*) (А*) pc; двойное преобразование иначе может возникнуть неоднозначность

class A : virtual public L { ... }; L в таблицу переносится и все го наслденики ссылаются именно на эту запись в табличке и не возникает коллизий элементов в L тут 	L <-- A <-- C --> B --> L

в наследовании коллизия возникает по одинаковому имени и в разных уровнях, например: L <-- A <-- C --> B --> L в A и В.


статические ПЕРЕМЕНННЫЕ класса надо обьявить в глобальной области видимости после обьявления класса 

cтатические методы не могут пользоваться нестатическими переменнымии this и не могут быть виртальными и константными

catch с базовым типом перехватывает производные типы

не забывать про вызовы деструкторов при выходе из областей видимости


int a() throw(int, double) {  - список исключений, которые может генерировать функция

шаблонные функции сами способны определять вызываемый тип по аргументам

у шаблонного класса нет параметров по умолчанию

методы шаблонного класса - автоматически шаблонные 	

бинарные операции, создаем внутри обьект и воращаем его НЕ по ссылке

унарные префиксные, меняем тот же и возвращаем по ссылке

унарные постфиксные, создаем новый, меняем старый, возвращаем новый не пос ссылке

виртуальность - глянул в базовый класс, запомнил прототип, если нашел в производном то дергаешь его, если не нашел то дергаешь в базовом
 
struct по умолчанию public наследование а class по умолчанию private наследование

explicit конструкторы - не пойдет автомаический вызов их

ostream & operator << (ostream & s, A& a) {
		s << a.n;
		return s;
	}

Если используем статическую функцию, возвращаемое значение -  тоже в static

dynamic cast вниз - только если методы виртуальные и обрабатывать Bad_cast catch (bad_cast)

template <typename T>

typename T::value_type

typename T::const_reverse_iterator
