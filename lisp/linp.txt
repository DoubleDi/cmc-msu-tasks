(defun check(x) (
    cond((atom x) nil)
        ((and (atom (cdr x)) (atom (car x))) (null (cdr x)))
        ((atom (car x)) (check (cdr x)))
        ((atom (cdr x)) (and (null (cdr x)) (check (car x))))
        (T (and (check (car x)) (check (cdr x))))))

Доказываем:
Завершимость.
Корректность проверки.

На выходе должен получиться T или nil в зависимости от того, можно ли S-выражение превратить в список

Оперируем мы с пространством S - выражений.
Строим прострнаство гипотез (S, <_s)
Зададим отношение порядка на (S, <_s) так:
S1 <_s S2 => n(S1) < n(S2), где n - количество атомов в S - выражении
транзитивность и наличие минимального элемента(1 атом) - выполнено.

1. Базис. Проверим для минимального элемента. Ответ - nil.
2. Пусть для всех S_i <_s S программа работает корректно.
3. Проверим для S:
((atom (car S)) (check (cdr S)))
((atom (cdr S)) (and (null (cdr S)) (check (car S))))
(T (and (check (car S)) (check (cdr S))))))
во всех трех ветках мы рекурсивно обращаемся к нашей функции с аргументами
(car S) <_s S и (cdr S) <_s S, для которых мы знаем, что программа работает корректно.
Также мы корректно обрабатываем результат этих вызовов, строя на их основе правильный ответ для S

Корректность проверки - доказана.
Завершимость - т к каждый раз мы обращаемся к функции с меньшим аргументом, корректно обработав
граничный случай завершимость доказана.
