Pointers

auto_ptr (deprecated) - нет копирования
scoped_ptr (replaced)
unique_ptr
shared_ptr
weak_ptr

ptr - удаляется методом deleter

передача в функцию по обычному указателю непонятно, кто им владеет и кому нужно его удалять


auto_ptr - передает владение над обьектом в другую функцию.

Хочется - не терять память, наследоваться и хранить в контейнерах

неявного приведения к умному указателю - нет

auto_ptr<A> a = new;
auto_ptr<A> b = a;
b -> f() - норм
a -> f() - все умерло, т к a больше ни на что не ссылается

vector < auto_ptr<T> > v;
v.push_back(auto_ptr<A>(new A());
sort(v.begin(), v.end());
вектор указателей делать нельзя с auto_ptr!!!


Запрещаем копирование - делаем move!
scoped_ptr и unique_ptr
Опять же нельзя пользоваться после передачи в функцию

Общие соглашения f (T *) - не получает владение над обьектом.
F(unique_ptr<T>) - получает владение над обьектом

f(unique_ptr<T>(new T()), unique_ptr<T>(new T())); // не безопасно, не понятно в каком порядке вычисляются аргументы
unique_ptr<T[5]>P(new T[5]);

чтобы избежать используем make_unique<T>();


shared_ptr
Указатель + счетчик ссылок

struct B{}; struct D : B{};
shared_ptr<B> spb(new D());
D * pd = dynamic_cast<D*>(spd.get());
shared_ptr<D> spd(pd); // это не очень!

нужно
spd = dynamic_pointer_cast<D>(spb);
всегда делать умный указатель вначале...

вместо new использовать make_shared<T>();


weak_ptr
p.lock() -> сделать shared_ptr;

struct A: enable_shared_from_this<A>
так просто делать shared_ptr из weak_ptr


intrusive_ptr like shared_ptr, but better realisation. (doesn't hold weak_ptrs)

изменение shared_ptr - не потоко-безопасно


new T // operator new(sizeof (T));
new (2, f) T // operator new (sizeof (T), 2, f);
new T[5] // operator new[] (sizeof(T) * 5);

без исключений
char * data = new (std::nothrow) char[100000000000000]; // возырвтит nullptr;

на стеке
char * data = malloc(10000);
char *p = new (data) char[10];



